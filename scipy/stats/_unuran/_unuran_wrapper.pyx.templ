# cython: language_level=3


DEF NPY_OLD = {NPY_OLD}


cimport cython
import numpy as np
cimport numpy as np
import warnings


__all__ = ["TDR", "DAU"]


# ===========================================================================
# Error Handling
# ===========================================================================


_global_err_reason = ""
_global_err_objid = ""
_global_err_errortype = ""
_global_err_eval = None


cdef void _error_handler(const char *objid, const char *file,
                         int line, const char *errortype,
                         int unur_errno, const char *reason):
    global _global_err_reason, _global_err_objid, _global_err_errortype
    _global_err_reason = str(reason.decode("utf-8"))
    _global_err_objid = str(objid.decode("utf-8"))
    _global_err_errortype = str(errortype.decode("utf-8"))


cdef void _set_error_handler():
    unur_set_error_handler(_error_handler)


# Replace UNU.RAN's error handler with our handler.
_set_error_handler()


cdef void _check_error(_errno=None) except *:
    global _global_err_reason, _global_err_objid, _global_err_errortype
    global _global_err_eval
    cdef str msg
    if _errno == None:
        _errno = unur_get_errno()
    unur_reset_errno()
    if isinstance(_global_err_eval, Exception):
        try:
            raise _global_err_eval
        except Exception as e:
            raise e
        finally:
            _global_err_eval = None
    if _errno != 0:
        msg = str(unur_get_strerror(_errno).decode("utf-8"))
        if _global_err_errortype == "error":
            if msg == "":
                raise ValueError("%d: %s" % (_errno, _global_err_reason))
            raise ValueError("%d: %s => %s" % (_errno, _global_err_reason,
                                               msg))
        else:  # warning
            if msg == "":
                warnings.warn("[object: %s] %d: %s" % (
                                  _global_err_objid, _errno,
                                  _global_err_reason
                              ), UserWarning)
            else:
                warnings.warn("[object: %s] %d: %s => %s" % (
                                  _global_err_objid, _errno,
                                  _global_err_reason, msg
                              ), UserWarning)


# ===========================================================================
# Helper Functions
# ===========================================================================


IF not NPY_OLD:
    from numpy.random cimport bitgen_t
    from cpython.pycapsule cimport PyCapsule_IsValid, PyCapsule_GetPointer

    cdef object _get_numpy_rng(object seed = None):
        if isinstance(seed, np.random.RandomState):
            return np.random.default_rng(seed._bit_generator)
        return np.random.default_rng(seed)

    cdef unur_urng * _get_urng(object numpy_rng) except *:
        """Get a UNU.RAN URNG using a NumPy Generator."""
        cdef bitgen_t *numpy_urng
        cdef unur_urng *unuran_urng

        capsule = numpy_rng.bit_generator.capsule
        cdef const char *capsule_name = "BitGenerator"

        if not PyCapsule_IsValid(capsule, capsule_name):
            raise ValueError("Invalid pointer to anon_func_state.")

        numpy_urng = <bitgen_t *> PyCapsule_GetPointer(capsule, capsule_name)

        unuran_urng = unur_urng_new(numpy_urng.next_double,
                                    <void *>(numpy_urng.state))
        _check_error()

        return unuran_urng
ELSE:
    cdef object _global_old_numpy_rng

    cdef object _get_numpy_rng(object seed = None):
        if (hasattr(np.random, "Generator") and
            isinstance(seed, np.random.Generator)):
            return seed
        elif isinstance(seed, np.random.RandomState):
            return seed
        return np.random.RandomState(seed)

    cdef double _next_double(void *state):
        global _global_old_numpy_rng
        return _global_old_numpy_rng.uniform()

    cdef unur_urng * _get_urng(object numpy_rng) except *:
        """Get a UNU.RAN URNG using a NumPy RandomState."""
        cdef unur_urng *unuran_urng
        global _global_old_numpy_rng

        _global_old_numpy_rng = numpy_rng

        unuran_urng = unur_urng_new(_next_double, NULL)
        _check_error()

        return unuran_urng


# ===========================================================================
# Setting the default and auxilary URNG.
# ===========================================================================


cdef unur_urng *_default_urng = NULL
cdef unur_urng *_default_urng_aux = NULL
# we need this otherwise the NumPy URNG will be
# garbage collected and the default URNG will be
# destroyed with it.
_default_numpy_rng = None


def _set_default_urng():
    global _default_urng, _default_urng_aux, _default_numpy_rng

    if _default_numpy_rng is None:
        # if a existing (stale) URNG is found, destroy it.
        if _default_urng != NULL:
            unur_urng_free(_default_urng)
            _default_urng = NULL

        # get a new NumPy RNG.
        _default_numpy_rng = _get_numpy_rng()

    # try to get a new UNU.RAN URNG.
    try:
        _default_urng = _get_urng(_default_numpy_rng)
    except ValueError as e:
        msg = "Failed to initialize the default URNG."
        raise RuntimeError(msg) from e

    # auxilary default uses the same underlying NumPy URNG.
    _default_urng_aux = _default_urng

    # set the defaults for UNU.RAN
    unur_set_default_urng(_default_urng)
    _check_error()
    unur_set_default_urng_aux(_default_urng_aux)
    _check_error()


# setup the default URNG on import.
_set_default_urng()


# ===========================================================================
# Global Attributes.
# ===========================================================================

_global_params = None

# For continuous distributions
_global_pdf = None
_global_dpdf = None

# For discrete distributions
_global_pmf = None


# ===========================================================================
# Wrappers for python functions.
# ===========================================================================


# Wrap PDF.
cdef double _pdf_wrapper(double x, const unur_distr *distr):
    global _global_pdf
    try:
        return _global_pdf(x, *_global_params)
    except Exception as e:
        global _global_err_eval
        _global_err_eval = e
        _global_pdf = lambda x: -1
        return -1

# Wrap DPDF.
cdef double _dpdf_wrapper(double x, const unur_distr *distr):
    global _global_dpdf
    try:
        return _global_dpdf(x, *_global_params)
    except Exception as e:
        global _global_err_eval
        _global_err_eval = e
        _global_dpdf = lambda x: -1
        return -1

# Wrap PMF.
cdef double _pmf_wrapper(int k, const unur_distr *distr):
    global _global_pmf
    try:
        return _global_pmf(k, *_global_params)
    except Exception as e:
        global _global_err_eval
        _global_err_eval = e
        _global_pmf = lambda x: -1
        return -1


# ===========================================================================
# Base class for all the methods.
# ===========================================================================

cdef class Method:
    cdef void _set_rng(self, object seed, unur_par *par,
                       unur_distr *distr) except *:
        cdef unur_urng *urng = NULL

        # If given, set a new NumPy's BitGenerator as the URNG.
        if seed is not None:
            self._numpy_rng = _get_numpy_rng(seed)
            urng = _get_urng(self._numpy_rng)
            _check_error(unur_set_urng(par, urng))

        # Initialize a UNU.RAN random number generator.
        rng = unur_init(par)
        _check_error()

        # Free the distribution. We don't need it anymore.
        unur_distr_free(distr)

        self._rng = rng
        self._urng = urng

    @cython.boundscheck(False)
    @cython.wraparound(False)
    cdef inline np.ndarray[np.float64_t, ndim=1] _sample_cont(
        self,
        Py_ssize_t size
    ):
        cdef unur_gen *rng = self._rng
        cdef np.ndarray[np.float64_t, ndim=1] out = \
            np.empty(size, dtype=np.float64)

        cdef Py_ssize_t i
        for i in range(size):
            out[i] = unur_sample_cont(rng)

        return out

    @cython.boundscheck(False)
    @cython.wraparound(False)
    cdef inline np.ndarray[np.int32_t, ndim=1] _sample_discr(
        self,
        Py_ssize_t size
    ):
        cdef unur_gen *rng = self._rng
        cdef np.ndarray[np.int32_t, ndim=1] out = \
            np.empty(size, dtype=np.int32)

        cdef Py_ssize_t i
        for i in range(size):
            out[i] = unur_sample_discr(rng)

        return out

    def __dealloc__(self):
        # Free everything.
        if self._rng != NULL:
            unur_free(self._rng)
        if self._urng != NULL:
            unur_urng_free(self._urng)


# ===========================================================================
# TDR method for sampling from continuous distributions.
# ===========================================================================


cdef class TDR(Method):
    """
    TDR Method for sampling from continuous distributions.

    Parameters
    ----------
    pdf : callable
        PDF of the distribution. The expected signature is:
        ``def pdf(x: float, *params) -> float`` where
        ``params`` are the parameters of the distribution.
    dpdf : callable
        Derivative of the PDF of the distribution. Same signature
        as the PDF.
    params : tuple, list, optional
        Parameters of the distribution. Default is an empty tuple.
    domain : tuple, list, optional
        A tuple or a list of two ``float``s. The first represents
        the lower bound and the second represents the upper bound.
        Default is negative infinity to infinity.
    c : float, optional
        The transformation to be used. For c=-0.5 (default), a inverse
        square root function is used. For c=1., a log transform is used.
    cpoints : int, optional
        The number of construction points. Default is 30.
    variant : str, optional
        The variant to use. Available options are 'ia', 'ps' (default),
        and 'gw'.
    seed : None, int, array_like[ints], SeedSequence, BitGenerator, Generator, optional
        Seed the generator.

    Methods
    -------
    sample(size=1)
        Sample from the distribution.

    Examples
    --------
    >>> from scipy.stats._unuran import TDR

    Suppose we want to sample from the following distribution:

         /  1 - x*x , |x| â‰¤ 1
    x = <
         \     0    , otherwise

    As this is a continuous distribution and the derivative is easy to
    obtain, we can use the TDR method:

    >>> rng = TDR(lambda x: 1 - x*x, lambda x: -2*x, params=(),
    ...           domain=(-1, 1), c=0., cpoints=10, variant='ia')

    Here, we use a log transform with 10 construction points and immediate
    acceptance. Now, we can sample from the distribution using the
    `sample` method:

    >>> rvs = rng.sample(size=100_000)

    We can verify that the samples are from the expected distribution:

    >>> import matploblib.pyplot as plt
    >>> pdf = lambda x: 1 - x*x
    >>> x = np.linspace(-1, 1, 1000)
    >>> px = pdf(x)
    >>> plt.plot(x, px)
    >>> plt.hist(rvs, bins=50, density=True)
    >>> plt.show()
    """
    def __cinit__(self, pdf, dpdf, params=(), domain=None,
                  c=-0.5, cpoints=30, variant="ps", seed=None):

        cdef unur_distr *distr
        cdef unur_par *par
        cdef unur_gen *rng

        # Set the global attributes
        global _global_pdf, _global_dpdf, _global_params
        _global_params = params
        _global_pdf = pdf
        _global_dpdf = dpdf

        # Create a new distribution.
        distr = unur_distr_cont_new()

        # Set the methods of the `distr` object.
        _check_error(unur_distr_cont_set_pdf(distr, _pdf_wrapper))
        _check_error(unur_distr_cont_set_dpdf(distr, _dpdf_wrapper))
        if domain:
            _check_error(unur_distr_cont_set_domain(distr, domain[0],
                                                    domain[1]))

        # Create a new method object.
        par = unur_tdr_new(distr)
        _check_error()

        # Set the attributes of the parameter object.
        _check_error(unur_tdr_set_c(par, c))
        _check_error(unur_tdr_set_cpoints(par, cpoints, NULL))
        if variant == "ps":
            unur_tdr_set_variant_ps(par)
        elif variant == "ia":
            unur_tdr_set_variant_ia(par)
        elif variant == "gw":
            unur_tdr_set_variant_gw(par)
        else:
            raise ValueError("Invalid option for the variant!")

        # Create a UNU.RAN RNG using the seed and the parameter object.
        self._set_rng(seed, par, distr)

    def sample(self, Py_ssize_t size=1):
        """
        Sample from the distribution.

        Parameters
        ----------
        size : int, optional
            The number of samples. Default is 1.

        Returns
        -------
        rvs : array_like with shape (size,)
            One dimensional NumPy array of random variates.
        """
        return self._sample_cont(size)


# ===========================================================================
# DAU method for sampling from discrete distributions.
# ===========================================================================


cdef class DAU(Method):
    """
    DAU Method for sampling from continuous distributions.

    Parameters
    ----------
    pv_or_pmf : array_like or callable
        Probability vector. If probability vector is not available, PMF is
        expected. PMF of the distribution. The expected signature is:
        ``def pmf(k: int, *params) -> float`` where
        ``params`` are the parameters of the distribution.
    params : tuple, list, optional
        Parameters of the distribution. Default is an empty tuple.
        Used only if a PMF is given. Ignored otherwise.
    domain : tuple, list, optional
        A tuple or a list of two ``float``s. The first represents
        the lower bound and the second represents the upper bound.
        Default is None. The domain MUST be finite and non-None when
        PV is not available.
    urnfactor : int, optional
        Set size of urn table relative to length of the probability vector.
        Default is 1.
    seed : None, int, array_like[ints], SeedSequence, BitGenerator, Generator, optional
        Seed the generator.

    Examples
    --------
    >>> from scipy.stats._unuran import DAU

    DAU accepts either a Probability Vector (PV) or the Probability
    Mass Function (PMF) of the discrete distribution. Say, we have a
    probability vector ``[0.18, 0.02, 0.8]``. We can use the DAU method
    to sample from this distribution:

    >>> rng = DAU([0.18, 0.02, 0.8], domain=(0, 2))
    >>> rvs = rng.sample(size=100_000)
    >>> rvs.mean()  # mean of the random variates.
    1.6257  # may vary
    >>> (0 * 0.18 + 1 * 0.02 + 2 * 0.8)  # mean of the actual distribution.
    1.62

    On the other hand, if a probability vector is not available, we can use
    a PMF along with a finite domain:

    >>> from math import factorial as f
    >>> from math import pow
    >>> pmf = lambda x, n, p : f(n)/(f(x)*f(n-x)) * pow(p, x)*pow(1-p, n-x)
    >>> n, p = 10, 0.2
    >>> rng = DAU(pmf=pmf, params=(n, p), domain=(0, n), urnfactor=2)
    >>> rvs = rng.sample(size=100_000)
    >>> rvs.mean(), rvs.var()  # mean and variance of the random variates.
    (2.00341, 1.6044183719000003)  # may vary
    >>> n*p, n*p*(1-p)  # actual mean and variance
    (2.0, 1.6)
    """
    def __cinit__(self, pv_or_pmf, params=(), domain=None,
                  urnfactor=1, seed=None):
        if callable(pv_or_pmf):
            pmf = pv_or_pmf
            pv = None
        else:
            pv = pv_or_pmf
            pmf = None

        cdef unur_distr *distr
        cdef unur_par *par
        cdef unur_gen *rng

        cdef np.ndarray[np.float64_t, ndim=1, mode = 'c'] pv_view
        global _global_pmf, _global_params

        if (pv is not None):
            pv_view = np.asarray(pv, dtype=np.float64)
            pv_view.setflags(write=False)

        # Set the global attributes
        _global_params = params
        if (pmf is not None):
            _global_pmf = pmf

        # Create a new distribution and set it's attributes.
        distr = unur_distr_discr_new()
        if (pv is not None):
            n_pv = len(pv_view)
            _check_error(
                unur_distr_discr_set_pv(distr,
                                        <const double *>(pv_view.data),
                                        n_pv)
            )
        else:
            _check_error(unur_distr_discr_set_pmf(distr, _pmf_wrapper))
        if (domain is not None):
            _check_error(unur_distr_discr_set_domain(distr, domain[0],
                                                     domain[1]))

        par = unur_dau_new(distr)
        _check_error()
        _check_error(unur_dau_set_urnfactor(par, urnfactor))

        # Create a UNU.RAN RNG using the seed and the parameter object.
        self._set_rng(seed, par, distr)

    def sample(self, Py_ssize_t size=1):
        """
        Sample from the distribution.

        Parameters
        ----------
        size : int, optional
            The number of samples. Default is 1.

        Returns
        -------
        rvs : array_like with shape (size,)
            One dimensional NumPy array of random variates.
        """
        return self._sample_discr(size)
